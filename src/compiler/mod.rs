pub mod lexer;
pub mod ast;
pub mod parser;
pub mod codegen;

use lexer::Lexer;
use parser::Parser;
use codegen::CodeGenerator;

#[derive(Debug)]
#[allow(clippy::enum_variant_names)]
pub enum CompilerError {
    LexError(lexer::LexError),
    ParseError(parser::ParseError),
    CodegenError(codegen::CompileError),
}

impl std::fmt::Display for CompilerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CompilerError::LexError(e) => write!(f, "Lexer error: {}", e),
            CompilerError::ParseError(e) => write!(f, "Parser error: {}", e),
            CompilerError::CodegenError(e) => write!(f, "Codegen error: {}", e),
        }
    }
}

impl std::error::Error for CompilerError {}

impl From<lexer::LexError> for CompilerError {
    fn from(err: lexer::LexError) -> Self {
        CompilerError::LexError(err)
    }
}

impl From<parser::ParseError> for CompilerError {
    fn from(err: parser::ParseError) -> Self {
        CompilerError::ParseError(err)
    }
}

impl From<codegen::CompileError> for CompilerError {
    fn from(err: codegen::CompileError) -> Self {
        CompilerError::CodegenError(err)
    }
}

pub struct Compiler {
    debug: bool,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            debug: false,
        }
    }
    
    pub fn with_debug(mut self, debug: bool) -> Self {
        self.debug = debug;
        self
    }
    
    pub fn compile(&self, source: &str) -> Result<Vec<u8>, CompilerError> {
        // Lexical analysis
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize()?;
        
        if self.debug {
            println!("Tokens: {:?}", tokens);
        }
        
        // Syntax analysis
        let mut parser = Parser::new(tokens);
        let program = parser.parse()?;
        
        if self.debug {
            use ast::AstVisitor;
            let mut printer = ast::AstPrinter::new();
            printer.visit_program(&program);
            println!("AST:\n{}", printer.output());
        }
        
        // Code generation
        let mut generator = CodeGenerator::new();
        let bytecode = generator.compile(&program)?;
        
        if self.debug {
            println!("Generated bytecode: {:02X?}", bytecode);
            println!("Bytecode length: {} bytes", bytecode.len());
        }
        
        Ok(bytecode)
    }
    
    pub fn compile_expression(&self, source: &str) -> Result<Vec<u8>, CompilerError> {
        // Lexical analysis
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize()?;
        
        // Parse just an expression
        let mut parser = Parser::new(tokens);
        let expr = parser.expression()?;
        
        // Generate code for the expression
        let mut generator = CodeGenerator::new();
        generator.visit_expression(&expr).map_err(CompilerError::CodegenError)?;
        
        // Add STOP to end execution
        generator.emit_opcode(crate::opcodes::OpCode::STOP);
        
        Ok(generator.bytecode)
    }
}

impl Default for Compiler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compile_simple_program() {
        let source = r#"
            let x = 42;
            let y = x + 10;
        "#;
        
        let compiler = Compiler::new().with_debug(true);
        let result = compiler.compile(source);
        assert!(result.is_ok());
        
        let bytecode = result.unwrap();
        assert!(!bytecode.is_empty());
        assert_eq!(*bytecode.last().unwrap(), 0x00); // Should end with STOP
    }

    #[test]
    fn test_compile_expression() {
        let compiler = Compiler::new();
        
        // Test simple literal
        let result = compiler.compile_expression("42");
        assert!(result.is_ok());
        
        // Test arithmetic
        let result = compiler.compile_expression("1 + 2 * 3");
        assert!(result.is_ok());
        
        // Test comparison
        let result = compiler.compile_expression("5 > 3");
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_compile_errors() {
        let compiler = Compiler::new();
        
        // Test lexer error
        let result = compiler.compile("let x = @invalid;");
        assert!(matches!(result, Err(CompilerError::LexError(_))));
        
        // Test parser error
        let result = compiler.compile("let x = ;");
        assert!(matches!(result, Err(CompilerError::ParseError(_))));
    }
}
